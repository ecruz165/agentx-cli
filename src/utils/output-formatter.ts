/**
 * Output formatting utilities for saving AI responses
 */

import fs from 'fs';
import path from 'path';
import { encode as encodeToon } from '@toon-format/toon';
import { ResponseOutputFormat } from '../types';

/**
 * Metadata for the AI response
 */
export interface ResponseMetadata {
  timestamp: string;
  provider: string;
  model?: string;
  alias: string;
  prompt: string;
  contextFiles: string[];
  version: string;
  contextSize?: number; // Total size of context in bytes
  config?: {
    knowledgeBase: string;
    maxContextSize: number;
    contextFormat: string;
    cacheEnabled: boolean;
  };
}

/**
 * Format AI response based on the specified format
 */
export function formatResponse(
  response: string,
  format: ResponseOutputFormat,
  metadata: ResponseMetadata
): string {
  switch (format) {
    case 'toon':
      return formatAsToon(response, metadata);
    case 'json':
      return formatAsJSON(response, metadata);
    case 'markdown':
      return formatAsMarkdown(response, metadata);
    case 'raw':
      return response;
    default:
      throw new Error(`Unknown output format: ${format}`);
  }
}

/**
 * Format response as TOON (Token-Oriented Object Notation)
 * TOON is a compact, human-readable format designed for LLMs
 */
function formatAsToon(response: string, metadata: ResponseMetadata): string {
  const data = {
    metadata: {
      timestamp: metadata.timestamp,
      provider: metadata.provider,
      alias: metadata.alias,
      version: metadata.version,
    },
    request: {
      prompt: metadata.prompt,
      contextFiles: metadata.contextFiles,
    },
    response: {
      content: response,
    },
  };

  // Use the @toon-format/toon library to encode the data
  return encodeToon(data);
}

/**
 * Format response as JSON
 */
function formatAsJSON(response: string, metadata: ResponseMetadata): string {
  const output = {
    metadata: {
      timestamp: metadata.timestamp,
      provider: metadata.provider,
      alias: metadata.alias,
      version: metadata.version,
    },
    request: {
      prompt: metadata.prompt,
      contextFiles: metadata.contextFiles,
    },
    response: {
      content: response,
    },
  };

  return JSON.stringify(output, null, 2);
}

/**
 * Format response as Markdown
 */
function formatAsMarkdown(response: string, metadata: ResponseMetadata): string {
  return `# AgentX AI Response

**Generated:** ${metadata.timestamp}  
**Provider:** ${metadata.provider}  
**Alias:** ${metadata.alias}  
**Version:** ${metadata.version}

## Prompt

\`\`\`
${metadata.prompt}
\`\`\`

## Context Files

${metadata.contextFiles.map(f => `- \`${f}\``).join('\n')}

## Response

${response}

---

*Generated by AgentX CLI v${metadata.version}*
`;
}

/**
 * Save formatted response to a file
 */
export function saveResponseToFile(
  content: string,
  outputPath: string
): void {
  const dir = path.dirname(outputPath);
  
  // Create directory if it doesn't exist
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  // Write file
  fs.writeFileSync(outputPath, content, 'utf-8');
}

/**
 * Get file extension for the format
 */
export function getFileExtension(format: ResponseOutputFormat): string {
  switch (format) {
    case 'toon':
      return '.toon';
    case 'json':
      return '.json';
    case 'markdown':
      return '.md';
    case 'raw':
      return '.txt';
    default:
      return '.txt';
  }
}

